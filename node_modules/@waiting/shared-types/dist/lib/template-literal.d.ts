declare type V = string | number | boolean | bigint;
export declare type StrSplit<S extends string, D extends string> = string extends S ? string[] : S extends `${infer T}${D}${infer U}` ? [T, ...StrSplit<U, D>] : [
    S
];
export declare type TupleJoin<T extends V[], D extends string> = T extends [] ? '' : T extends [unknown] ? `${T[0]}` : T extends [unknown, ...infer U] ? `${T[0]}${D}${TupleJoin<U, D>}` : string;
declare type FormatCapitalize<T extends V[]> = T extends [] ? [] : T extends [string] ? [`${Capitalize<T[0]>}`] : T extends [string, ...infer U] ? [`${Capitalize<T[0]>}`, ...FormatCapitalize<U & V[]>] : [
];
declare type FormatCamelCase<T extends V[]> = T extends [] ? [] : T extends [unknown] ? [T[0]] : T extends [unknown, ...infer U] ? [T[0], ...FormatCapitalize<U & V[]>] : [
];
export declare type SnakeToCamel<T extends string, D extends string = '_' | '-'> = TupleJoin<FormatCamelCase<StrSplit<T, D>>, ''>;
export declare type SnakeToPascal<T extends string, D extends string = '_' | '-'> = TupleJoin<FormatCapitalize<StrSplit<T, D>>, ''>;
export {};
