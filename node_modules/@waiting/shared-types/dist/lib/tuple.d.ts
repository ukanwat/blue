/** Get the first element */
export declare type TupleHead<T extends unknown[]> = T[0];
/** Remove the first element */
export declare type TupleTail<T extends unknown[]> = T extends [] ? [] : T extends [unknown] ? [] : T extends [unknown, ...infer U] ? U : unknown[];
/** Get the last element */
export declare type TupleLast<T extends any[]> = T[TupleTail<T>['length']];
/** Remove the last element */
export declare type TupleRemoveLast<T extends any[]> = TypeAssert<Overwrite<TupleTail<T>, T>, any[]>;
/** Insert element at first */
export declare type TupleUnshift<T extends unknown[], X> = [X, ...T];
/** Append element at last */
export declare type TuplePush<T extends any[], X> = [...T, X];
/** Concat two tuples */
export declare type TupleConcat<A extends unknown[], B extends unknown[]> = [...A, ...B];
export declare type TypeAssert<T, A> = T extends A ? T : never;
export declare type Overwrite<T, S extends any> = {
    [P in keyof T]: S[P];
};
/**
 * Whether literal type is in Tuple contains literal,
 *
 * @example ```ts
 * type Foo = isInType<['ab', 'cd'], 'ab'>
 * ```
 * @returns boolean
 */
export declare type isInLiteralTuple<T extends (string | number | symbol)[], K extends string | number | symbol> = Extract<T[number], K> extends never ? false : true;
export declare type TupleToUnion<T extends unknown[]> = T[number];
