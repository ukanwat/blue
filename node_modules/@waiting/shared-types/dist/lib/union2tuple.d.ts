/**
 * Note: order of result is not exact
 * @example ```
 *  type LongerUnion = { name: 'shanon' } | 1 | 2 | 3
 *  type TestType = UnionToTuple<LongerUnion> // [3, 2, {name: 'shanon'}, 1]
 * ```
 * @see https://stackoverflow.com/a/55858763
 */
export declare type UnionToTuple<U> = UnionToTupleRecursively<[], U>;
declare type Overwrite<T, S extends any> = {
    [P in keyof T]: S[P];
};
declare type TupleUnshift<T extends any[], X> = T extends any ? ((x: X, ...t: T) => void) extends (...t: infer R) => void ? R : never : never;
declare type TuplePush<T extends any[], X> = T extends any ? Overwrite<TupleUnshift<T, any>, T & {
    [x: string]: X;
}> : never;
export declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;
declare type UnionToOvlds<U> = UnionToIntersection<U extends any ? (f: U) => void : never>;
declare type PopUnion<U> = UnionToOvlds<U> extends ((a: infer A) => void) ? A : never;
declare type UnionToTupleRecursively<T extends any[], U> = {
    1: T;
    0: PopUnion<U> extends infer SELF ? UnionToTupleRecursively<TuplePush<T, SELF>, Exclude<U, SELF>> : never;
}[[U] extends [never] ? 1 : 0];
export {};
