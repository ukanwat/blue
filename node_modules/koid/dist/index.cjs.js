/**
 * koid
 * k-ordered, conflict-free ids generator in a distributed environment
 *
 * @version 2.1.1
 * @author waiting
 * @license MIT
 * @link https://github.com/waitingsong/koid#readme
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var assert = require('assert');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var assert__default = /*#__PURE__*/_interopDefaultLegacy(assert);

function parseConfig(config) {
    /* istanbul ignore else */
    if (typeof config === 'undefined') {
        const dc = genConfigRandom();
        return parseConfigDc(dc);
    }
    if (typeof config.node === 'number') {
        const configNode = {
            node: config.node,
            epoch: config.epoch,
        };
        return parseConfigNode(configNode);
    }
    else {
        const conf = config;
        const configDc = {
            dataCenter: conf.dataCenter,
            worker: conf.worker,
            epoch: conf.epoch,
        };
        return parseConfigDc(configDc);
    }
}
/**
 * Generate random id
 */
function genConfigRandom() {
    const id = Date.now() & 0x3FF;
    const config = parseConfigNode({ node: id });
    const ret = {
        dataCenter: config.dataCenter,
        worker: config.worker,
        epoch: 0,
    };
    return ret;
}
function parseConfigDc(config) {
    const dataCenter = config.dataCenter & 0x1F;
    const worker = config.worker & 0x1F;
    const id = (dataCenter << 5 | worker) & 0x3FF;
    const opts = {
        genId: id << 12,
        epoch: typeof config.epoch === 'number' ? config.epoch : 0,
        dataCenter,
        worker,
    };
    return opts;
}
function parseConfigNode(config) {
    const id = config.node & 0x3FF;
    const dataCenter = id >> 5;
    const worker = id & 0x1F;
    const opts = {
        genId: id << 12,
        epoch: typeof config.epoch === 'number' ? config.epoch : 0,
        dataCenter,
        worker,
    };
    return opts;
}

/* eslint-disable no-mixed-operators */
(function (KoidMsg) {
    KoidMsg["SeqExceed"] = "Sequence exceeded its maximum value";
    KoidMsg["ClockBack"] = "Clock moved backwards";
    KoidMsg["NotValidBigintId"] = "Not an valid bigint id. Should gross then 0 and less equal then 9223372036854775807n";
    KoidMsg["NotValidBigintString"] = "Not an valid bigint string";
    KoidMsg["NotValidHexString"] = "Not an valid hex string";
    KoidMsg["NotValidIdFormat"] = "Not an valid id value";
})(exports.KoidMsg || (exports.KoidMsg = {}));

/* eslint-disable no-bitwise */
const POW10 = Math.pow(2, 10);
const POW26 = Math.pow(2, 26);
const maxBigintId = BigInt('9223372036854775807');
/**
 * Retrieve Id info from hex, bigint string, Buffer.
 * like '50dddcbfb5c00001' or '0x50dddcbfb5c00001' or "6755455236955799552"
 */
function retrieveFromId(id) {
    /* istanbul ignore else */
    if (!id) {
        throw new TypeError(exports.KoidMsg.NotValidIdFormat);
    }
    switch (typeof id) {
        case 'bigint':
            return retrieveFromBigint(id);
        case 'string':
            return retrieveFromStr(id);
        default:
            return retrieveFromBuffer(id);
    }
}
/**
 * Retrieve Id info from hex and bigint string
 * like '50dddcbfb5c00001' or '0x50dddcbfb5c00001' or "6755455236955799552"
 */
function retrieveFromStr(id) {
    const int8 = isValidBigintStr(id);
    return int8
        ? retrieveFromBigint(int8)
        : retrieveFromHex(id);
}
/**
 * Detect bigint string, eg. '6755455236955799552'
 */
function isValidBigintStr(id) {
    const str = id.toLowerCase().trim();
    if (/^[1-9]\d{18}$/u.test(str)) {
        const int8 = BigInt(str);
        if (isValidBigintId(int8)) {
            return int8;
        }
        throw new TypeError(exports.KoidMsg.NotValidBigintString + `: "${str}"`);
    }
    return false;
}
function isValidBigintId(id) {
    return !!(id >= 0 && id <= maxBigintId);
}
function isValidHexString(id) {
    let hex = id.toLowerCase().trim();
    /* istanbul ignore else */
    if (!/^[\dxa-f]{16}/u.test(hex)) {
        return false;
    }
    /* istanbul ignore else */
    if (hex.startsWith('0x')) {
        hex = hex.slice(2);
    }
    const buf = Buffer.from(hex, 'hex');
    return buf.length === 8 ? buf : false;
}
/**
 * Retrieve Id info from hex,
 * like '50dddcbfb5c00001' or '0x50dddcbfb5c00001'
 */
function retrieveFromHex(id) {
    const buf = isValidHexString(id);
    /* istanbul ignore else */
    if (!buf) {
        throw new TypeError(exports.KoidMsg.NotValidHexString + `: "${id}"`);
    }
    return retrieveFromBuffer(buf);
}
function retrieveFromBigint(id) {
    const buf = Buffer.alloc(8);
    buf.writeBigUInt64BE(id);
    return retrieveFromBuffer(buf);
}
function retrieveFromBuffer(id) {
    assert__default['default'](id.length === 8);
    // 00000010 00110000 10000001 01010000 11101100 00.000000 00000000 00000000
    // 5d c2 d8 27 be 7f f0 00
    // 01011101 11000010 11011000 00100111 10111110 01.111111 1111.0000 00000000
    isValidBigintId(id.readBigInt64BE());
    const p0 = id.readUInt32BE();
    const p4 = id.readUInt8(4);
    const p5 = id.readUInt8(5);
    // eslint-disable-next-line no-mixed-operators
    const timestamp = p0 * POW10 + (p4 << 2) + (p5 >> 6);
    // eslint-disable-next-line no-mixed-operators
    const dataCenter = (p5 & 0x3F) >> 1 & 0x1F;
    const p6 = id.readUInt8(6);
    const worker = ((p5 & 0x3F & 1) << 4) + (p6 >> 4) & 0x1F;
    const p7 = id.readUInt8(7);
    const sequence = (p6 << 8) + p7 & 0x1F;
    const hex = id.toString('hex');
    const ret = {
        dataCenter, worker, timestamp, sequence, hex,
    };
    return ret;
}

/* eslint-disable no-mixed-operators */
class Koid {
    constructor(options) {
        this.options = options;
        this.POW10 = POW10;
        this.POW26 = POW26;
        this.genId = options.genId;
        this.epoch = options.epoch;
        this.seqMask = 0xFFF;
        this.lastTime = 0;
        this.seq = 0;
    }
    /**
     * Generate an id, type of Buffer
     */
    get next() {
        const id = Buffer.alloc(8);
        const time = Date.now() - this.epoch;
        // Generates id in the same millisecond as the previous id
        if (time < this.lastTime) {
            const msg = exports.KoidMsg.ClockBack + `. Refusing to generate id for ${this.lastTime - time} milliseconds`;
            throw new Error(msg);
        }
        else if (time === this.lastTime) {
            this.seq = this.seq + 1 & this.seqMask;
            // If all sequence values (4096 unique values including 0) have been used
            // to generate ids in the current millisecond
            // sequence counter exceeded its max value (4095)
            /* istanbul ignore else */
            if (this.seq === 0) {
                throw new Error(exports.KoidMsg.SeqExceed);
            }
        }
        else {
            this.seq = 0;
        }
        this.lastTime = time;
        id.writeUInt32BE((time & 0x3) << 22 | this.genId | this.seq, 4);
        id.writeUInt8(Math.floor(time / 4) & 0xFF, 4);
        id.writeUInt16BE(Math.floor(time / this.POW10) & 0xFFFF, 2);
        id.writeUInt16BE(Math.floor(time / this.POW26) & 0xFFFF, 0);
        return id;
    }
    /**
     * Generate an id, type of bigint
     */
    get nextBigint() {
        return this.next.readBigInt64BE();
    }
    get config() {
        const ret = {
            ...this.options,
        };
        return ret;
    }
    retrieveFromId(id) {
        return retrieveFromId(id);
    }
}

function KoidFactory(config) {
    const opts = parseConfig(config);
    const inst = new Koid(opts);
    return inst;
}

exports.KoidFactory = KoidFactory;
exports.genConfigRandom = genConfigRandom;
exports.retrieveFromId = retrieveFromId;
//# sourceMappingURL=index.cjs.js.map
